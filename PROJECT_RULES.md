# 项目规则

## 规则 1：Superpowers 技能使用规范

**为什么需要这条规则？**

> Superpowers 技能是团队一致性的核心保障。它们不是束缚，而是经过验证的最佳实践，能够帮助我们：
> - 减少返工和遗漏
> - 保持代码质量的一致性
> - 让新成员快速融入团队节奏
> - 降低知识传递的成本

**核心原则：按需使用，而非机械执行**

> 技能的目的是帮助我们做得更好，而不是增加负担。当某个技能明显不适用时，可以跳过，但请在方案文档中说明理由。

### 1.1 技能使用时机

| 场景 | 必须使用的技能 | 说明 |
|------|---------------|------|
| 添加新功能、修改行为 | `brainstorming` | 在动手之前理解需求和设计 |
| 实现功能或修复 bug | `test-driven-development` | 先写测试，再用测试驱动实现 |
| 代码完成后 | `requesting-code-review` | 至少一次人工审查 |
| 收到审查反馈 | `receiving-code-review` | 认真对待每条反馈 |
| 遇到 bug 或测试失败 | `systematic-debugging` | 系统化定位问题根源 |
| 使用子代理执行计划 | `subagent-driven-development` | 保持任务的一致性 |
| 需要隔离工作环境 | `using-git-worktrees` | 避免污染主工作区 |
| 执行已有的实现计划 | `executing-plans` | 按计划推进，便于追踪 |
| 完成开发工作 | `finishing-a-development-branch` | 规范化收尾 |
| 声称工作完成前 | `verification-before-completion` | 用证据证明，而非猜测 |

### 1.2 如何使用技能

1. **识别场景**：根据上述表格判断需要使用哪个技能
2. **加载技能**：使用 `/skill` 命令加载对应的 superpowers 技能
3. **遵循流程**：严格按照技能提供的流程执行
4. **记录结果**：将技能执行结果记录在方案文档中

### 1.3 常见问题

**Q：如果不确定该用哪个技能怎么办？**
A：优先使用 `brainstorming` 来理清思路，或者询问团队成员。

**Q：技能流程太繁琐，可以跳过部分吗？**
A：可以跳过明显不适用的步骤，但请在记录中说明跳过的原因。

**Q：技能的结果如何保存？**
A：将技能执行的关键结果（如方案设计、测试用例、审查反馈）记录在 `docs/plans/` 或方案文档中。

## 规则 2：方案生成

**为什么需要方案文档？**

> 方案文档是团队协作的契约，它能够：
> - 在动手之前统一团队对需求的理解
> - 记录设计决策和背后的理由
> - 为后续的实现提供清晰的路线图
> - 便于评估变更的影响范围

### 2.1 方案生成流程

1. 使用 `brainstorming` 技能理解需求和设计
2. 编写方案文档
3. 询问用户是否保存到 `docs/plans/` 目录
4. 若当前处于 plan mode，不执行任何覆写操作

### 2.2 方案文件命名规范

- 使用描述性名称，清晰表达方案内容
- 使用连字符或下划线分隔单词
- 包含版本号或日期以区分不同版本
- 示例：`2026-02-04-fix-zero-display-bug.md`

### 2.3 方案内容要求

| 章节 | 必须包含的内容 |
|------|---------------|
| 概述 | 用 1-2 句话描述方案的目的 |
| 背景 | 为什么需要这个方案 |
| 设计思路 | 核心设计决策和理由 |
| 实现步骤 | 具体的实现步骤 |
| 依赖 | 前置条件和外部依赖 |
| 验收标准 | 如何验证方案是否成功 |

### 2.4 特殊场景处理

**plan mode 注意事项：**
- 不执行 bash 命令
- 不修改非方案文档的文件
- 专注于方案的设计和讨论
- 切换到 build mode 后再进行文件保存

**plan mode 切换方式：**
- 使用 `/mode build` 命令切换到 build mode

## 规则 3：项目状态记录

**为什么需要记录项目状态？**

> 项目状态文档是团队共享知识的重要载体：
> - 让所有成员快速了解项目的当前进展
> - 便于追踪功能完成情况和问题修复进度
> - 为版本发布提供清晰的变更记录
> - 帮助新成员快速了解项目历史

### 3.1 记录时机

每次完成以下操作后，必须更新项目状态：
- 新功能开发完成
- Bug 修复完成
- 重构或优化完成
- 依赖版本升级
- 重大配置变更

### 3.2 状态记录内容

| 类别 | 记录内容 | 示例 |
|------|---------|------|
| 已完成 | 功能名称、完成时间 | - 投资组合图表（2026-02-04） |
| 已修复 | Bug 描述、修复时间 | - 零金额显示异常（2026-02-04） |
| 待完成 | 功能名称、计划时间 | - 收益预测功能 |
| 已知问题 | 问题描述、影响范围 | - 大数据量加载性能待优化 |
| 版本号 | 当前版本号 | v1.2.0 |

### 3.3 状态文件位置

项目状态记录在 `PROJECT_STATUS.md` 文件中。

### 3.4 状态更新示例

```markdown
## 项目状态

### 已完成功能
- [2026-02-04] 投资组合收益图表
- [2026-02-03] 基金编辑功能
- [2026-02-03] 分类卡片百分比显示优化

### 待完成功能
- [待定] 收益预测功能
- [待定] 数据导出功能

### 已修复 Bug
- [2026-02-04] 零金额显示 NaN 问题
- [2026-02-04] 编辑模式状态异常

### 已知问题
- 大数据量加载时界面有卡顿
- 深色模式下部分图表颜色不协调

### 当前版本
v1.2.0
```

## 规则 4：Git 协作规范

**为什么需要这条规则？**

> 统一的 Git 工作流能够：
> - 让团队成员快速理解代码变更的上下文
> - 减少合并冲突和协作摩擦
> - 便于追溯问题和回滚代码
> - 让 Code Review 更加高效

### 4.1 Branch 命名规范

**命名格式：**
```
<类型>/<描述>
```

**类型前缀：**

| 类型 | 用途 | 示例 |
|------|------|------|
| `feat/` | 新功能开发 | `feat/add-investment-chart` |
| `fix/` | Bug 修复 | `fix/zero-division-error` |
| `refactor/` | 代码重构 | `refactor/portfolio-repository` |
| `docs/` | 文档更新 | `docs/update-readme` |
| `chore/` | 构建/工具/依赖更新 | `chore/update-flutter-version` |
| `test/` | 测试相关 | `test/add-portfolio-unit-tests` |

**为什么这样约定？**
- 前缀让 branch 用途一目了然
- 便于筛选和搜索特定类型的分支
- 与 Conventional Commits 保持一致

### 4.2 Commit Message 规范

**格式：**
```
<类型>: <简要描述>

[可选的正文]

[可选的脚注]
```

**示例：**
```
feat: 添加投资组合收益曲线图表

- 支持日/周/月/年的视图切换
- 支持缩放和滑动查看
- 使用 fl_chart 实现

Closes #123
```

**类型前缀：**

| 类型 | 描述 |
|------|------|
| `feat` | 新功能 |
| `fix` | Bug 修复 |
| `docs` | 文档更新 |
| `style` | 代码格式（不影响功能） |
| `refactor` | 重构（既不修复 bug 也不添加功能） |
| `perf` | 性能优化 |
| `test` | 添加/修改测试 |
| `chore` | 构建工具/辅助工具的变更 |

**为什么使用中文描述？**
- 项目主要使用中文交流
- 中文描述更符合团队习惯
- 便于与非英语母语者协作

### 4.3 Commit 频率建议

**原则：**
- 小而频繁的提交优于大而稀疏的提交
- 每个 commit 应该有明确的单一目的
- 避免在单个 commit 中混合多个不相关的变更

**示例：**
```
✅ 好的提交：
- feat: 添加收益计算功能
- fix: 修复收益计算溢出问题
- test: 添加收益计算单元测试

❌ 不好的提交：
- feat: 添加收益计算功能并修复界面显示问题
```

**为什么？**
- 便于回滚（如果某处出问题，只回滚相关 commit）
- 便于 Code Review（每次审查的内容更集中）
- 便于生成 CHANGELOG

### 4.4 合并策略

**Merge vs Rebase：**

| 场景 | 推荐方式 | 理由 |
|------|---------|------|
| 功能分支合并到主分支 | Squash Merge | 保持主分支历史清晰 |
| 更新本地分支 | Rebase | 避免无意义的 merge commit |
| 协作分支 | Merge with commit | 保留协作历史 |

**合并步骤：**
1. 确保本地分支是最新的
2. 运行测试确保没有问题
3. 发起 PR 进行 Code Review
4. 审查通过后合并

### 4.5 常见问题

**Q：已经推送的 commit 发现写错了怎么办？**
A：
- 如果还没有合并，使用 `git commit --amend` 然后 `git push --force`
- 如果已经合并，创建一个新的 commit 来修正

**Q：如何处理 sensitive 信息（如 API key）被提交了？**
A：
1. 立即修改泄露的凭证
2. 使用 `git filter-branch` 或 BFG Repo-Cleaner 移除历史记录
3. 强制推送

**Q：分支太多不知道怎么清理怎么办？**
A：合并后及时删除本地和远程分支
```bash
# 删除本地分支
git branch -d feature/xxx

# 删除远程分支
git push origin --delete feature/xxx
```

### 4.6 Git 操作注意事项

**必须遵守：**
- 每次内容更新后，不自动执行 Git 提交或推送，而是询问用户
- 若用户允许，才执行 commit 和 push 操作

**操作前确认：**
- 执行 git 操作前，确认当前分支
- 确认没有未保存的重要更改
- 确认操作的影响范围

## 规则 5：代码风格规范

**为什么需要这条规则？**

> 统一的代码风格能够：
> - 减少认知负担：团队成员可以快速理解他人的代码
> - 降低合并冲突：统一的格式减少无意义的 diff
> - 提升代码可读性：一致的风格本身就是最好的文档
> - 便于自动化：格式检查和 lint 可以自动执行

### 5.1 Flutter/Dart 特定规范

**命名约定：**

| 类型 | 规则 | 示例 |
|------|------|------|
| 类/枚举 | PascalCase | `class InvestmentPortfolio {}` |
| 常量 | kCamelCase | `const kDefaultThreshold = 0.05;` |
| 变量/函数 | camelCase | `final totalAmount = 1000;` |
| 私有成员 | 下划线前缀 | `int _internalCounter = 0;` |
| 文件名 | snake_case | `investment_repository.dart` |

**为什么这样约定？**
- Dart 官方推荐这些约定，遵循社区标准可以降低学习成本
- 私有成员以下划线开头，便于快速识别作用域

### 5.2 代码组织

**文件长度控制：**
- 单个文件不超过 300 行（不包括空行和注释）
- 超过 300 行时，考虑拆分到多个文件

**为什么？**
- 过长的文件难以阅读和维护
- IDE 打开大文件时性能下降
- 便于精确追踪变更

**函数长度控制：**
- 单个函数不超过 50 行
- 超过 20 行时，考虑是否可以拆分成多个函数

**为什么？**
- 短函数更易于测试和调试
- 单一职责原则的体现
- 便于理解函数意图

### 5.3 注释规范

**必须添加注释的场景：**
- 复杂的业务逻辑（超过 5 行代码的判断）
- 非常规的解决方案（绕过 bug、临时方案）
- 重要的设计决策（"为什么"而非"做了什么"）
- 公开的 API 或公共方法

**不建议添加注释的场景：**
- 显而易见的代码（`i++`、`if (amount > 0)`）
- 代码本身可以自我表达的情况
- TODO/FIXME 超过一周未处理

**为什么？**
- 注释需要维护，过时的注释比没有注释更有害
- 代码应该是自文档化的

### 5.4 异常处理

**原则：**
- 明确区分可恢复错误和不可恢复错误
- 不要吞掉异常，除非有明确的理由
- 记录异常时包含足够的上下文信息

**示例：**
```dart
// ✅ 好的做法
try {
  await repository.savePortfolio(portfolio);
} on StorageException catch (e, stack) {
  logger.error('Failed to save portfolio', error: e, stackTrace: stack);
  // 向用户显示友好的错误提示
  showErrorSnackbar('保存失败，请稍后重试');
}

// ❌ 不好的做法
try {
  await repository.savePortfolio(portfolio);
} catch (e) {
  // 吞掉了所有异常，用户不知道发生了什么
}
```

### 5.5 代码格式

**必须遵循：**
- 使用 `dart format` 格式化代码
- 使用 `flutter analyze` 检查代码
- 解决所有警告和错误后再提交

**IDE 配置建议：**
- 开启保存时自动格式化
- 开启保存时自动运行分析器

## 规则 6：代码审查流程

**为什么需要这条规则？**

> 代码审查是保证代码质量的关键环节，它能够：
> - 发现潜在的 bug 和设计问题
> - 促进知识共享和团队成长
> - 保持代码库的一致性
> - 减少后续维护成本

### 6.1 提交前检查清单

在发起代码审查前，请确保：

- [ ] 代码符合代码风格规范（规则 5）
- [ ] 所有自动化测试通过
- [ ] 没有未解决的 lint 警告
- [ ] 新增代码有适当的测试覆盖
- [ ] 文档已更新（如需要）
- [ ] PR 描述清晰，包含截图或录屏（如 UI 变更）

**为什么？**
- 在发起审查前自检，可以减少来回沟通的成本
- 让审查者专注于更高层次的设计和逻辑问题

### 6.2 PR 描述模板

```markdown
## 概述
<!-- 用 1-2 句话描述这次变更的目的 -->

## 变更内容
<!-- 详细列出修改了什么 -->

## 测试方案
<!-- 如何验证这次变更是否正确 -->
- [ ] 手动测试步骤：
- [ ] 自动化测试（如有）：

## 截图/录屏（如有 UI 变更）
<!-- 放截图或录屏 -->

## 相关链接
<!-- 相关 issue、PR、文档等 -->
```

**为什么需要模板？**
- 确保审查者能够快速理解变更的背景
- 减少来回询问的时间
- 便于后续追溯

### 6.3 审查者指南

**审查原则：**
1. **关注代码本身**：对事不对人
2. **区分等级**：
   - 🔴 **必须修复**：Bug、安全问题、严重的设计问题
   - 🟡 **建议修改**：代码风格、可读性、性能优化
   - 🟢 **可选建议**：个人偏好、主观意见

3. **提供理由**：每条审查意见都应说明原因
4. **及时响应**：24 小时内响应审查请求

**如何给出有效的审查意见：**
```
// ✅ 好的意见
建议：这里使用 `kDefaultThreshold` 而不是硬编码 0.05
理由：便于后续统一调整，避免魔法数字

// ❌ 不好的意见
改成 0.05
```

### 6.4 响应审查反馈

**收到审查意见后：**

1. **认真阅读**：理解审查者的意图
2. **澄清疑问**：如果不理解，询问而不是猜测
3. **及时响应**：每条意见都应有明确的回复（已修改/已解释/不同意）
4. **解释异议**：如果不同意审查意见，请说明理由

**示例：**
```
审查者：建议使用 Future.value() 来返回同步值

开发者：
> 已修改，改为 Future.value(threshold)
```

### 6.5 审查流程

1. **发起 PR**：创建 Pull Request
2. **自动检查**：CI 流水线自动运行测试和 lint
3. **人工审查**：至少一位团队成员进行 Code Review
4. **修改完善**：根据反馈修改代码
5. **再次审查**：如有必要，进行第二轮审查
6. **合并代码**：审查通过后合并到目标分支

## 规则 7：文档维护规范

**为什么需要这条规则？**

> 文档是团队知识传承的载体：
> - 便于新成员快速上手
> - 减少口口相传带来的信息失真
> - 便于后续维护和重构
> - 提升团队整体的效率

### 7.1 文档类型与更新频率

| 文档类型 | 文件位置 | 更新频率 | 负责人 |
|---------|---------|---------|-------|
| 项目规则 | `PROJECT_RULES.md` | 重大变更时 | 所有贡献者 |
| 项目状态 | `PROJECT_STATUS.md` | 每次功能完成后 | 实现者 |
| 方案文档 | `docs/plans/*.md` | 方案确定时 | 作者 |
| API 文档 | `docs/api/` | API 变更时 | 实现者 |
| README | `README.md` | 重大变更时 | 项目负责人 |

### 7.2 文档更新原则

**及时性原则：**
- 文档应与代码同步更新，避免出现"文档债务"
- 功能完成后，必须同步更新相关文档

**简洁性原则：**
- 使用简单的语言，避免行话和缩写
- 一个概念一个地方，避免重复
- 使用主动语态

**可执行原则：**
- 文档应包含具体的命令、步骤或示例
- 避免模糊的描述（如"优化性能" → "将加载时间从 2s 降至 500ms"）

### 7.3 文档位置规范

**方案文档：**
- 位置：`docs/plans/`
- 命名：`YYYY-MM-DD-<描述>.md`

**API 文档：**
- 位置：`docs/api/`
- 命名：`<模块名>.md`

**设计文档：**
- 位置：`docs/design/`
- 命名：`<设计主题>.md`

### 7.4 README 结构模板

```markdown
# 项目名称

一句话描述项目做什么。

## 快速开始

```bash
# 安装依赖
flutter pub get

# 运行项目
flutter run
```

## 项目结构

<!-- 简要说明目录结构 -->

## 贡献指南

<!-- 如何参与贡献 -->

## 许可证
```

### 7.5 文档审查

**需要审查的场景：**
- 新增重要文档
- 文档结构重大变更
- 文档内容可能存在错误

**审查重点：**
- 准确性：文档内容是否正确
- 完整性：是否覆盖所有关键信息
- 可读性：是否易于理解
- 可执行性：步骤是否可操作
